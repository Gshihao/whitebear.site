<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>java学习笔记</title>
        <style type="text/css">
        body { background:#FAFAFA; }
        .memos { width:100%w; margin:0 auto; }
        .memos h1 { margin-top:30px; }
        .memo { margin:20px 0; background:#FFF; padding:20px; border-radius:6px; }
        .memo:hover { box-shadow: 0px 2px 16px #DDDDDD; }
        .memo .time { color:#8D8D8D; font-size:12px; }
        .memo .content { color: #323232; font-size: 14px; }
        .memo .content p { line-height:1.8; min-height:20px; margin:0; }
        .memo .content ul,
        .memo .content ol { padding-inline-start: 20px; margin: 0; }
        .memo .content li { line-height: 1.8; }
        .memo .files img { width:100%; border:1px solid #E6E6E6; border-radius: 4px; margin:6px 0; }
        </style>
    </head>
    <body>
        <div class="memos">
            <h1></h1>
                        <div class="memo">
                <div class="time">2022-10-20 16:13:13</div>
                <div class="content">
                    <p>#java/基础/方法</p><p>https://www.runoob.com/java/java-methods.html</p><p>Java方法是语句的集合，它们在一起执行一个功能。</p><p></p><p>方法是解决一类问题的步骤的有序组合</p><p>方法包含于类或对象中</p><p>方法在程序中被创建，在其他地方被引用</p><p></p><p>方法的优点</p><p>1. 使程序变得更简短而清晰。</p><p>2. 有利于程序维护。</p><p>3. 可以提高程序开发的效率。</p><p>4. 提高了代码的重用性。</p><p>方法的命名规则</p><p>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：addPerson。</p><p>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如 testPop_emptyStack。</p><p></p><p>方法的定义</p><p>一般情况下，定义一个方法包含以下语法：</p><p></p><p>修饰符 返回值类型 方法名(参数类型 参数名){</p><p>...</p><p>方法体</p><p>...</p><p>return 返回值;</p><p>}</p><p>方法的重载</p><p>#java/基础/方法/方法的重载</p><p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p><p></p><p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p><p></p><p>public static double max(double num1, double num2) {</p><p>if (num1 &gt; num2)</p><p>return num1;</p><p>else</p><p>return num2;</p><p>}</p><p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p><p></p><p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p><p></p><p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p><p></p><p>Java编译器根据方法签名判断哪个方法应该被调用。</p><p></p><p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p><p></p><p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p><p></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-19 17:48:16</div>
                <div class="content">
                    <p>#java/基础/正则表达式</p><p>https://www.runoob.com/java/java-regular-expressions.html</p><p>正则表达式实例</p><p>一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 "Hello World" 字符串。</p><p></p><p>.（点号）也是一个正则表达式，它匹配任何一个字符如："a" 或 "1"。</p><p></p><p>下表列出了一些正则表达式的实例及描述：</p><p></p><p>正则表达式	描述</p><p>this is text</p><p></p><p>匹配字符串 "this is text"</p><p></p><p>this\s+is\s+text</p><p></p><p>注意字符串中的 \s+。</p><p></p><p>匹配单词 "this" 后面的 \s+ 可以匹配多个空格，之后匹配 is 字符串，再之后 \s+ 匹配多个空格然后再跟上 text 字符串。</p><p></p><p>可以匹配这个实例：this is text</p><p></p><p>^\d+(\.\d+)?</p><p></p><p>^ 定义了以什么开始</p><p></p><p>\d+ 匹配一个或多个数字</p><p></p><p>? 设置括号内的选项是可选的</p><p></p><p>\. 匹配 "."</p><p></p><p>可以匹配的实例："5", "1.5" 和 "2.21"。</p><p></p><p>Java 正则表达式和 Perl 的是最为相似的。</p><p></p><p>java.util.regex 包主要包括以下三个类：</p><p></p><p>Pattern 类：</p><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p><p></p><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p><p></p><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p><p></p><p>以下实例中使用了正则表达式 .*runoob.* 用于查找字符串中是否包了 runoob 子串：</p><p></p><p>实例</p><p>import java.util.regex.*;</p><p> </p><p>class RegexExample1{</p><p>   public static void main(String[] args){</p><p>      String content = "I am noob " +</p><p>        "from runoob.com.";</p><p> </p><p>      String pattern = ".*runoob.*";</p><p> </p><p>      boolean isMatch = Pattern.matches(pattern, content);</p><p>      System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);</p><p>   }</p><p>}</p><p>实例输出结果为：</p><p></p><p>字符串中是否包含了 'runoob' 子字符串? true</p><p>捕获组</p><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p></p><p>例如，正则表达式 (dog) 创建了单一分组，组里包含"d"，"o"，和"g"。</p><p></p><p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p><p></p><p>((A)(B(C)))</p><p>(A)</p><p>(B(C))</p><p>(C)</p><p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p><p></p><p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。</p><p></p><p>实例</p><p>下面的例子说明如何从一个给定的字符串中找到数字串：</p><p></p><p>RegexMatches.java 文件代码：</p><p>import java.util.regex.Matcher;</p><p>import java.util.regex.Pattern;</p><p> </p><p>public class RegexMatches</p><p>{</p><p>    public static void main( String[] args ){</p><p> </p><p>      // 按指定模式在字符串查找</p><p>      String line = "This order was placed for QT3000! OK?";</p><p>      String pattern = "(\\D*)(\\d+)(.*)";</p><p> </p><p>      // 创建 Pattern 对象</p><p>      Pattern r = Pattern.compile(pattern);</p><p> </p><p>      // 现在创建 matcher 对象</p><p>      Matcher m = r.matcher(line);</p><p>      if (m.find( )) {</p><p>         System.out.println("Found value: " + m.group(0) );</p><p>         System.out.println("Found value: " + m.group(1) );</p><p>         System.out.println("Found value: " + m.group(2) );</p><p>         System.out.println("Found value: " + m.group(3) ); </p><p>      } else {</p><p>         System.out.println("NO MATCH");</p><p>      }</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>Found value: This order was placed for QT3000! OK?</p><p>Found value: This order was placed for QT</p><p>Found value: 3000</p><p>Found value: ! OK?</p><p>正则表达式语法</p><p>在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</p><p></p><p>在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</p><p></p><p>所以，在其他的语言中（如 Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\。</p><p></p><p>System.out.print("\\");    // 输出为 \</p><p>System.out.print("\\\\");  // 输出为 \\</p><p>字符</p><p></p><p>说明</p><p></p><p>\</p><p></p><p>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， n匹配字符 n。\n 匹配换行符。序列 \\\\ 匹配 \\ ，\\( 匹配 (。</p><p></p><p>^</p><p></p><p>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。</p><p></p><p>$</p><p></p><p>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。</p><p></p><p>*</p><p></p><p>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。</p><p></p><p>+</p><p></p><p>一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。</p><p></p><p>?</p><p></p><p>零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。</p><p></p><p>{n}</p><p></p><p>n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。</p><p></p><p>{n,}</p><p></p><p>n 是非负整数。至少匹配 n 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。</p><p></p><p>{n,m}</p><p></p><p>m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。</p><p></p><p>?</p><p></p><p>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。</p><p></p><p>.</p><p></p><p>匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。</p><p></p><p>(pattern)</p><p></p><p>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。</p><p></p><p>(?:pattern)</p><p></p><p>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 'industry|industries' 更经济的表达式。</p><p></p><p>(?=pattern)</p><p></p><p>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95|98|NT|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p><p></p><p>(?!pattern)</p><p></p><p>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95|98|NT|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p><p></p><p>x|y</p><p></p><p>匹配 x 或 y。例如，'z|food' 匹配"z"或"food"。'(z|f)ood' 匹配"zood"或"food"。</p><p></p><p>[xyz]</p><p></p><p>字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。</p><p></p><p>[^xyz]</p><p></p><p>反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。</p><p></p><p>[a-z]</p><p></p><p>字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。</p><p></p><p>[^a-z]</p><p></p><p>反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。</p><p></p><p>\b</p><p></p><p>匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。</p><p></p><p>\B</p><p></p><p>非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。</p><p></p><p>\cx</p><p></p><p>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。</p><p></p><p>\d</p><p></p><p>数字字符匹配。等效于 [0-9]。</p><p></p><p>\D</p><p></p><p>非数字字符匹配。等效于 [^0-9]。</p><p></p><p>\f</p><p></p><p>换页符匹配。等效于 \x0c 和 \cL。</p><p></p><p>\n</p><p></p><p>换行符匹配。等效于 \x0a 和 \cJ。</p><p></p><p>\r</p><p></p><p>匹配一个回车符。等效于 \x0d 和 \cM。</p><p></p><p>\s</p><p></p><p>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</p><p></p><p>\S</p><p></p><p>匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</p><p></p><p>\t</p><p></p><p>制表符匹配。与 \x09 和 \cI 等效。</p><p></p><p>\v</p><p></p><p>垂直制表符匹配。与 \x0b 和 \cK 等效。</p><p></p><p>\w</p><p></p><p>匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。</p><p></p><p>\W</p><p></p><p>与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。</p><p></p><p>\xn</p><p></p><p>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&amp;"1"等效。允许在正则表达式中使用 ASCII 代码。</p><p></p><p>\num</p><p></p><p>匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。</p><p></p><p>\n</p><p></p><p>标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</p><p></p><p>\nm</p><p></p><p>标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</p><p></p><p>\nml</p><p></p><p>当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</p><p></p><p>\un</p><p></p><p>匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</p><p></p><p>根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 "\b" 与单个退格字符匹配，而 "\\b" 与单词边界匹配。字符串字面值 "\(hello\)" 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 "\\(hello\\)"。</p><p></p><p>Matcher 类的方法</p><p>索引方法</p><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><p></p><p>序号	方法及说明</p><p>1	public int start()</p><p>返回以前匹配的初始索引。</p><p>2	public int start(int group)</p><p> 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</p><p>3	public int end()</p><p>返回最后匹配字符之后的偏移量。</p><p>4	public int end(int group)</p><p>返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</p><p>查找方法</p><p>查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p><p></p><p>序号	方法及说明</p><p>1	public boolean lookingAt()</p><p> 尝试将从区域开头开始的输入序列与该模式匹配。</p><p>2	public boolean find()</p><p>尝试查找与该模式匹配的输入序列的下一个子序列。</p><p>3	public boolean find(int start）</p><p>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</p><p>4	public boolean matches()</p><p>尝试将整个区域与模式匹配。</p><p>替换方法</p><p>替换方法是替换输入字符串里文本的方法：</p><p></p><p>序号	方法及说明</p><p>1	public Matcher appendReplacement(StringBuffer sb, String replacement)</p><p>实现非终端添加和替换步骤。</p><p>2	public StringBuffer appendTail(StringBuffer sb)</p><p>实现终端添加和替换步骤。</p><p>3	public String replaceAll(String replacement)</p><p> 替换模式与给定替换字符串相匹配的输入序列的每个子序列。</p><p>4	public String replaceFirst(String replacement)</p><p> 替换模式与给定替换字符串匹配的输入序列的第一个子序列。</p><p>5	public static String quoteReplacement(String s)</p><p>返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</p><p>start 和 end 方法</p><p>下面是一个对单词 "cat" 出现在输入字符串中出现次数进行计数的例子：</p><p></p><p>RegexMatches.java 文件代码：</p><p>import java.util.regex.Matcher;</p><p>import java.util.regex.Pattern;</p><p> </p><p>public class RegexMatches</p><p>{</p><p>    private static final String REGEX = "\\bcat\\b";</p><p>    private static final String INPUT =</p><p>                                    "cat cat cat cattie cat";</p><p> </p><p>    public static void main( String[] args ){</p><p>       Pattern p = Pattern.compile(REGEX);</p><p>       Matcher m = p.matcher(INPUT); // 获取 matcher 对象</p><p>       int count = 0;</p><p> </p><p>       while(m.find()) {</p><p>         count++;</p><p>         System.out.println("Match number "+count);</p><p>         System.out.println("start(): "+m.start());</p><p>         System.out.println("end(): "+m.end());</p><p>      }</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>Match number 1</p><p>start(): 0</p><p>end(): 3</p><p>Match number 2</p><p>start(): 4</p><p>end(): 7</p><p>Match number 3</p><p>start(): 8</p><p>end(): 11</p><p>Match number 4</p><p>start(): 19</p><p>end(): 22</p><p>可以看到这个例子是使用单词边界，以确保字母 "c" "a" "t" 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。</p><p></p><p>Start 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。</p><p></p><p>matches 和 lookingAt 方法</p><p>matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。</p><p></p><p>lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。</p><p></p><p>这两个方法经常在输入字符串的开始使用。</p><p></p><p>我们通过下面这个例子，来解释这个功能：</p><p></p><p>RegexMatches.java 文件代码：</p><p>import java.util.regex.Matcher;</p><p>import java.util.regex.Pattern;</p><p> </p><p>public class RegexMatches</p><p>{</p><p>    private static final String REGEX = "foo";</p><p>    private static final String INPUT = "fooooooooooooooooo";</p><p>    private static final String INPUT2 = "ooooofoooooooooooo";</p><p>    private static Pattern pattern;</p><p>    private static Matcher matcher;</p><p>    private static Matcher matcher2;</p><p> </p><p>    public static void main( String[] args ){</p><p>       pattern = Pattern.compile(REGEX);</p><p>       matcher = pattern.matcher(INPUT);</p><p>       matcher2 = pattern.matcher(INPUT2);</p><p> </p><p>       System.out.println("Current REGEX is: "+REGEX);</p><p>       System.out.println("Current INPUT is: "+INPUT);</p><p>       System.out.println("Current INPUT2 is: "+INPUT2);</p><p> </p><p> </p><p>       System.out.println("lookingAt(): "+matcher.lookingAt());</p><p>       System.out.println("matches(): "+matcher.matches());</p><p>       System.out.println("lookingAt(): "+matcher2.lookingAt());</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>Current REGEX is: foo</p><p>Current INPUT is: fooooooooooooooooo</p><p>Current INPUT2 is: ooooofoooooooooooo</p><p>lookingAt(): true</p><p>matches(): false</p><p>lookingAt(): false</p><p>replaceFirst 和 replaceAll 方法</p><p>replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</p><p></p><p>下面的例子来解释这个功能：</p><p></p><p>RegexMatches.java 文件代码：</p><p>import java.util.regex.Matcher;</p><p>import java.util.regex.Pattern;</p><p> </p><p>public class RegexMatches</p><p>{</p><p>    private static String REGEX = "dog";</p><p>    private static String INPUT = "The dog says meow. " +</p><p>                                    "All dogs say meow.";</p><p>    private static String REPLACE = "cat";</p><p> </p><p>    public static void main(String[] args) {</p><p>       Pattern p = Pattern.compile(REGEX);</p><p>       // get a matcher object</p><p>       Matcher m = p.matcher(INPUT); </p><p>       INPUT = m.replaceAll(REPLACE);</p><p>       System.out.println(INPUT);</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>The cat says meow. All cats say meow.</p><p>appendReplacement 和 appendTail 方法</p><p>Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换：</p><p></p><p>看下面的例子来解释这个功能：</p><p></p><p>RegexMatches.java 文件代码：</p><p>import java.util.regex.Matcher;</p><p>import java.util.regex.Pattern;</p><p> </p><p>public class RegexMatches</p><p>{</p><p>   private static String REGEX = "a*b";</p><p>   private static String INPUT = "aabfooaabfooabfoobkkk";</p><p>   private static String REPLACE = "-";</p><p>   public static void main(String[] args) {</p><p>      Pattern p = Pattern.compile(REGEX);</p><p>      // 获取 matcher 对象</p><p>      Matcher m = p.matcher(INPUT);</p><p>      StringBuffer sb = new StringBuffer();</p><p>      while(m.find()){</p><p>         m.appendReplacement(sb,REPLACE);</p><p>      }</p><p>      m.appendTail(sb);</p><p>      System.out.println(sb.toString());</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>-foo-foo-foo-kkk</p><p>PatternSyntaxException 类的方法</p><p>PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。</p><p></p><p>PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。</p><p></p><p>序号	方法及说明</p><p>1	public String getDescription()</p><p>获取错误的描述。</p><p>2	public int getIndex()</p><p> 获取错误的索引。</p><p>3	public String getPattern()</p><p>获取错误的正则表达式模式。</p><p>4	public String getMessage()</p><p>返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-19 17:40:05</div>
                <div class="content">
                    <p>#java/基础/时间</p><p>https://www.runoob.com/java/java-date-time.html</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-19 17:34:11</div>
                <div class="content">
                    <p>#java/基础/数组</p><p>https://www.runoob.com/java/java-array.html</p><p></p><p>声明</p><p>dataType[] arrayRefVar; // 首选的方法</p><p>或</p><p>dataType arrayRefVar[]; // 效果相同，但不是首选方法</p><p></p><p>创建数组</p><p>Java语言使用new操作符来创建数组，语法如下：</p><p></p><p>arrayRefVar = new dataType[arraySize];</p><p>上面的语法语句做了两件事：</p><p></p><p>一、使用 dataType[arraySize] 创建了一个数组。</p><p>二、把新创建的数组的引用赋值给变量 arrayRefVar。</p><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p><p></p><p>dataType[] arrayRefVar = new dataType[arraySize];</p><p>另外，你还可以使用如下的方式创建数组。</p><p></p><p>dataType[] arrayRefVar = {value0, value1, ..., valuek};</p><p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p><p></p><p>实例</p><p>下面的语句首先声明了一个数组变量 myList，接着创建了一个包含 10 个 double 类型元素的数组，并且把它的引用赋值给 myList 变量。</p><p></p><p>TestArray.java 文件代码：</p><p>public class TestArray {</p><p>   public static void main(String[] args) {</p><p>      // 数组大小</p><p>      int size = 10;</p><p>      // 定义数组</p><p>      double[] myList = new double[size];</p><p>      myList[0] = 5.6;</p><p>      myList[1] = 4.5;</p><p>      myList[2] = 3.3;</p><p>      myList[3] = 13.2;</p><p>      myList[4] = 4.0;</p><p>      myList[5] = 34.33;</p><p>      myList[6] = 34.0;</p><p>      myList[7] = 45.45;</p><p>      myList[8] = 99.993;</p><p>      myList[9] = 11123;</p><p>      // 计算所有元素的总和</p><p>      double total = 0;</p><p>      for (int i = 0; i &lt; size; i++) {</p><p>         total += myList[i];</p><p>      }</p><p>      System.out.println("总和为： " + total);</p><p>   }</p><p>}</p><p>以上实例输出结果为：</p><p></p><p>总和为： 11367.373</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-19 17:27:39</div>
                <div class="content">
                    <p>#java/基础/JavaStringBuffe和StringBuilder 类</p><p></p><p>https://www.runoob.com/java/java-stringbuffer.html</p><p></p><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p></p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p></p><p></p><p></p><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p><p></p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p></p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-18 17:06:49</div>
                <div class="content">
                    <p>#java/心得/java选择单个字符</p><p></p><p>#java/基础/Character </p><p>String hj="a😀2😍";</p><p>		char hh=hj.charAt(0);</p><p>选择索引为0的字符</p><p>		System.out.println(hh);</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-17 14:30:11</div>
                <div class="content">
                    <p>#java/基础/string</p><p>https://www.runoob.com/java/java-string.html</p><p>Java String 类</p><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。</p><p></p><p>创建字符串</p><p>创建字符串最简单的方式如下:</p><p></p><p>String str = "Runoob";</p><p>在代码中遇到字符串常量时，这里的值是 "Runoob"，编译器会使用该值创建一个 String 对象。</p><p></p><p>和其它对象一样，可以使用关键字和构造方法来创建 String 对象。</p><p></p><p>用构造函数创建字符串：</p><p></p><p>String str2=new String("Runoob");</p><p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p><p></p><p>String s1 = "Runoob";              // String 直接创建</p><p>String s2 = "Runoob";              // String 直接创建</p><p>String s3 = s1;                    // 相同引用</p><p>String s4 = new String("Runoob");   // String 对象创建</p><p>String s5 = new String("Runoob");   // String 对象创建</p><p></p><p></p><p>String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p><p></p><p>StringDemo.java 文件代码：</p><p>public class StringDemo{</p><p>   public static void main(String args[]){</p><p>      char[] helloArray = { 'r', 'u', 'n', 'o', 'o', 'b'};</p><p>      String helloString = new String(helloArray);  </p><p>      System.out.println( helloString );</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>runoob</p><p>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p><p></p><p>如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</p><p></p><p>字符串长度</p><p>用于获取有关对象的信息的方法称为访问器方法。</p><p></p><p>String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p><p></p><p>下面的代码执行后，len 变量等于 14:</p><p></p><p>StringDemo.java 文件代码：</p><p>public class StringDemo {</p><p>    public static void main(String args[]) {</p><p>        String site = "www.runoob.com";</p><p>        int len = site.length();</p><p>        System.out.println( "菜鸟教程网址长度 : " + len );</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>菜鸟教程网址长度 : 14</p><p>连接字符串</p><p>String 类提供了连接两个字符串的方法：</p><p></p><p>string1.concat(string2);</p><p>返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：</p><p></p><p>"我的名字是 ".concat("Runoob");</p><p>更常用的是使用'+'操作符来连接字符串，如：</p><p></p><p>"Hello," + " runoob" + "!"</p><p>结果如下:</p><p></p><p>"Hello, runoob!"</p><p>下面是一个例子:</p><p></p><p>StringDemo.java 文件代码：</p><p>public class StringDemo {</p><p>    public static void main(String args[]) {     </p><p>        String string1 = "菜鸟教程网址：";     </p><p>        System.out.println("1、" + string1 + "www.runoob.com");  </p><p>    }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>1、菜鸟教程网址：www.runoob.com</p><p>创建格式化字符串</p><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p><p></p><p>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。</p><p></p><p>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p><p></p><p>如下所示：</p><p></p><p>System.out.printf("浮点型变量的值为 " +</p><p>                  "%f, 整型变量的值为 " +</p><p>                  " %d, 字符串变量的值为 " +</p><p>                  "is %s", floatVar, intVar, stringVar);</p><p>你也可以这样写</p><p></p><p>String fs;</p><p>fs = String.format("浮点型变量的值为 " +</p><p>                   "%f, 整型变量的值为 " +</p><p>                   " %d, 字符串变量的值为 " +</p><p>                   " %s", floatVar, intVar, stringVar);</p><p>String 方法</p><p>下面是 String 类支持的方法，更多详细，参看 Java String API 文档:</p><p></p><p>SN(序号)	方法描述</p><p>1	char charAt(int index)</p><p>返回指定索引处的 char 值。</p><p>2	int compareTo(Object o)</p><p>把这个字符串和另一个对象比较。</p><p>3	int compareTo(String anotherString)</p><p>按字典顺序比较两个字符串。</p><p>4	int compareToIgnoreCase(String str)</p><p>按字典顺序比较两个字符串，不考虑大小写。</p><p>5	String concat(String str)</p><p>将指定字符串连接到此字符串的结尾。</p><p>6	boolean contentEquals(StringBuffer sb)</p><p>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</p><p>7	static String copyValueOf(char[] data)</p><p>返回指定数组中表示该字符序列的 String。</p><p>8	static String copyValueOf(char[] data, int offset, int count)</p><p>返回指定数组中表示该字符序列的 String。</p><p>9	boolean endsWith(String suffix)</p><p>测试此字符串是否以指定的后缀结束。</p><p>10	boolean equals(Object anObject)</p><p>将此字符串与指定的对象比较。</p><p>11	boolean equalsIgnoreCase(String anotherString)</p><p>将此 String 与另一个 String 比较，不考虑大小写。</p><p>12	byte[] getBytes()</p><p> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p><p>13	byte[] getBytes(String charsetName)</p><p>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p><p>14	void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</p><p>将字符从此字符串复制到目标字符数组。</p><p>15	int hashCode()</p><p>返回此字符串的哈希码。</p><p>16	int indexOf(int ch)</p><p>返回指定字符在此字符串中第一次出现处的索引。</p><p>17	int indexOf(int ch, int fromIndex)</p><p>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</p><p>18	int indexOf(String str)</p><p> 返回指定子字符串在此字符串中第一次出现处的索引。</p><p>19	int indexOf(String str, int fromIndex)</p><p>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p><p>20	String intern()</p><p> 返回字符串对象的规范化表示形式。</p><p>21	int lastIndexOf(int ch)</p><p> 返回指定字符在此字符串中最后一次出现处的索引。</p><p>22	int lastIndexOf(int ch, int fromIndex)</p><p>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</p><p>23	int lastIndexOf(String str)</p><p>返回指定子字符串在此字符串中最右边出现处的索引。</p><p>24	int lastIndexOf(String str, int fromIndex)</p><p> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p><p>25	int length()</p><p>返回此字符串的长度。</p><p>26	boolean matches(String regex)</p><p>告知此字符串是否匹配给定的正则表达式。</p><p>27	boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</p><p>测试两个字符串区域是否相等。</p><p>28	boolean regionMatches(int toffset, String other, int ooffset, int len)</p><p>测试两个字符串区域是否相等。</p><p>29	String replace(char oldChar, char newChar)</p><p>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p><p>30	String replaceAll(String regex, String replacement)</p><p>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p><p>31	String replaceFirst(String regex, String replacement)</p><p> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p><p>32	String[] split(String regex)</p><p>根据给定正则表达式的匹配拆分此字符串。</p><p>33	String[] split(String regex, int limit)</p><p>根据匹配给定的正则表达式来拆分此字符串。</p><p>34	boolean startsWith(String prefix)</p><p>测试此字符串是否以指定的前缀开始。</p><p>35	boolean startsWith(String prefix, int toffset)</p><p>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</p><p>36	CharSequence subSequence(int beginIndex, int endIndex)</p><p> 返回一个新的字符序列，它是此序列的一个子序列。</p><p>37	String substring(int beginIndex)</p><p>返回一个新的字符串，它是此字符串的一个子字符串。</p><p>38	String substring(int beginIndex, int endIndex)</p><p>返回一个新字符串，它是此字符串的一个子字符串。</p><p>39	char[] toCharArray()</p><p>将此字符串转换为一个新的字符数组。</p><p>40	String toLowerCase()</p><p>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</p><p>41	String toLowerCase(Locale locale)</p><p> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</p><p>42	String toString()</p><p> 返回此对象本身（它已经是一个字符串！）。</p><p>43	String toUpperCase()</p><p>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</p><p>44	String toUpperCase(Locale locale)</p><p>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</p><p>45	String trim()</p><p>返回字符串的副本，忽略前导空白和尾部空白。</p><p>46	static String valueOf(primitive data type x)</p><p>返回给定data type类型x参数的字符串表示形式。</p><p>47	contains(CharSequence chars)</p><p>判断是否包含指定的字符系列。</p><p>48	isEmpty()</p><p>判断字符串是否为空。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-17 14:14:40</div>
                <div class="content">
                    <p>#java/基础/Character 类</p><p>https://www.runoob.com/java/java-character.html</p><p>Java Character 类</p><p>Character 类用于对单个字符进行操作。</p><p></p><p>Character 类在对象中包装一个基本类型 char 的值</p><p></p><p>实例</p><p>char ch = 'a';</p><p> </p><p>// Unicode 字符表示形式</p><p>char uniChar = '\u039A'; </p><p> </p><p>// 字符数组</p><p>char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };</p><p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。</p><p></p><p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：</p><p></p><p>Character ch = new Character('a');</p><p>在某些情况下，Java编译器会自动创建一个Character对象。</p><p></p><p>例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p><p></p><p>实例</p><p>// 原始字符 'a' 装箱到 Character 对象 ch 中</p><p>Character ch = 'a';</p><p> </p><p>// 原始字符 'x' 用 test 方法装箱</p><p>// 返回拆箱的值到 'c'</p><p>char c = test('x');</p><p>转义序列</p><p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。</p><p></p><p>下面列表展示了Java的转义序列：</p><p></p><p>转义序列	描述</p><p>\t	在文中该处插入一个tab键</p><p>\b	在文中该处插入一个后退键</p><p>\n	在文中该处换行</p><p>\r	在文中该处插入回车</p><p>\f	在文中该处插入换页符</p><p>\'	在文中该处插入单引号</p><p>\"	在文中该处插入双引号</p><p>\\	在文中该处插入反斜杠</p><p>实例</p><p>当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。</p><p></p><p>以下实例转义双引号并输出：</p><p></p><p>Test.java 文件代码：</p><p>public class Test {</p><p> </p><p>   public static void main(String[] args) {</p><p>      System.out.println("访问\"菜鸟教程!\"");</p><p>   }</p><p>}</p><p>以上实例编译运行结果如下：</p><p></p><p>访问"菜鸟教程!"</p><p>Character 方法</p><p>下面是Character类的方法：</p><p></p><p>序号	方法与描述</p><p>1	isLetter()</p><p>是否是一个字母</p><p>2	isDigit()</p><p>是否是一个数字字符</p><p>3	isWhitespace()</p><p>是否是一个空白字符</p><p>4	isUpperCase()</p><p>是否是大写字母</p><p>5	isLowerCase()</p><p>是否是小写字母</p><p>6	toUpperCase()</p><p>指定字母的大写形式</p><p>7	toLowerCase()</p><p>指定字母的小写形式</p><p>8	toString()</p><p>返回字符的字符串形式，字符串的长度仅为1</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-17 14:11:55</div>
                <div class="content">
                    <p>#java/基础/java.Match</p><p></p><p>https://www.runoob.com/java/java-number.html</p><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p></p><p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p><p></p><p>Number &amp; Math 类方法</p><p>下面的表中列出的是 Number &amp; Math 类常用的一些方法：</p><p></p><p>序号	方法与描述</p><p>1	xxxValue()</p><p>将 Number 对象转换为xxx数据类型的值并返回。</p><p>2	compareTo()</p><p>将number对象与参数比较。</p><p>3	equals()</p><p>判断number对象是否与参数相等。</p><p>4	valueOf()</p><p>返回一个 Number 对象指定的内置数据类型</p><p>5	toString()</p><p>以字符串形式返回值。</p><p>6	parseInt()</p><p>将字符串解析为int类型。</p><p>7	abs()</p><p>返回参数的绝对值。</p><p>8	ceil()</p><p>返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</p><p>9	floor()</p><p>返回小于等于（&lt;=）给定参数的最大整数 。</p><p>10	rint()</p><p>返回与参数最接近的整数。返回类型为double。</p><p>11	round()</p><p>它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</p><p>12	min()</p><p>返回两个参数中的最小值。</p><p>13	max()</p><p>返回两个参数中的最大值。</p><p>14	exp()</p><p>返回自然数底数e的参数次方。</p><p>15	log()</p><p>返回参数的自然数底数的对数值。</p><p>16	pow()</p><p>返回第一个参数的第二个参数次方。</p><p>17	sqrt()</p><p>求参数的算术平方根。</p><p>18	sin()</p><p>求指定double类型参数的正弦值。</p><p>19	cos()</p><p>求指定double类型参数的余弦值。</p><p>20	tan()</p><p>求指定double类型参数的正切值。</p><p>21	asin()</p><p>求指定double类型参数的反正弦值。</p><p>22	acos()</p><p>求指定double类型参数的反余弦值。</p><p>23	atan()</p><p>求指定double类型参数的反正切值。</p><p>24	atan2()</p><p>将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</p><p>25	toDegrees()</p><p>将参数转化为角度。</p><p>26	toRadians()</p><p>将角度转换为弧度。</p><p>27	random()</p><p>返回一个随机数。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-17 14:07:43</div>
                <div class="content">
                    <p>#java/基础/swith case</p><p></p><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><p></p><p>语法</p><p>switch case 语句语法格式如下：</p><p></p><p>switch(expression){</p><p>    case value :</p><p>       //语句</p><p>       break; //可选</p><p>    case value :</p><p>       //语句</p><p>       break; //可选</p><p>    //你可以有任意数量的case语句</p><p>    default : //可选</p><p>       //语句</p><p>}</p><p>switch case 语句有如下规则：</p><p></p><p>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</p><p></p><p>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</p><p></p><p>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</p><p></p><p>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</p><p></p><p>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</p><p></p><p>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</p><p></p><p>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</p><p></p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 16:07:43</div>
                <div class="content">
                    <p>#java/基础/循环结构</p><p>https://www.runoob.com/java/java-loop.html</p><p>Java中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p></p><p><b>while 循环#java/基础/循环结构/while循环</b></p><p>while是最基本的循环，它的结构为：</p><p>while( 布尔表达式 ) {</p><p>//循环内容</p><p>}</p><p>只要布尔表达式为 true，循环就会一直执行下去。</p><p></p><p>do…while 循环</p><p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p></p><p><b>do…while 循环#java/基础/循环结构/do…while 循环</b></p><p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p><p></p><p>do {</p><p>//代码语句</p><p>}while(布尔表达式);</p><p>注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p><p></p><p><b>for循环#java/基础/循环结构/for循环</b></p><p>虽然所有循环结构都可以用 while 或者 do...while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p><p></p><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p><p></p><p>for(初始化; 布尔表达式; 更新) {</p><p>//代码语句</p><p>}</p><p>关于 for 循环有以下几点说明：</p><p></p><p>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</p><p>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</p><p>执行一次循环后，更新循环控制变量。</p><p>再次检测布尔表达式。循环执行上面的过程。</p><p></p><p><b>Java 增强 for 循环#java/基础/循环结构/java增强for循环</b></p><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p><p></p><p>Java 增强 for 循环语法格式如下:</p><p></p><p>for(声明语句 : 表达式)</p><p>{</p><p>//代码句子</p><p>}</p><p>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p></p><p>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 13:22:25</div>
                <div class="content">
                    <p>#java/基础/运算符</p><p>链接</p><p>https://www.runoob.com/java/java-operators.html</p><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><p>注:System.out.println("a+b="+(a+b));</p><p><b>算术运算符#java/基础/运算符/算术运算符</b></p><p></p><p>操作符	描述	例子</p><p>+	加法 - 相加运算符两侧的值	A + B 等于 30</p><p>-	减法 - 左操作数减去右操作数	A – B 等于 -10</p><p>*	乘法 - 相乘操作符两侧的值	A * B等于200</p><p>/	除法 - 左操作数除以右操作数	B / A等于2</p><p>％	取余 - 左操作数除以右操作数的余数	B%A等于0</p><p>++	自增: 操作数的值增加1	B++ 或 ++B 等于 21（区别详见下文）</p><p>--	自减: 操作数的值减少1	B-- 或 --B 等于 19（区别详见下文）</p><p><b>关系运算符#java/基础/运算符/关系运算符</b></p><p>==	检查如果两个操作数的值是否相等，如果相等则条件为真。	（A == B）为假。</p><p>!=	检查如果两个操作数的值是否相等，如果值不相等则条件为真。	(A != B) 为真。</p><p>&gt; 	检查左操作数的值是否大于右操作数的值，如果是那么条件为真。	（A&gt; B）为假。</p><p>&lt; 	检查左操作数的值是否小于右操作数的值，如果是那么条件为真。	（A &lt;B）为真。</p><p>&gt;=	检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。	（A&gt; = B）为假。</p><p>&lt;=	检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。	（A &lt;= B）为真。</p><p>位运算符#java/基础/运算符/位运算符</p><p>＆	如果相对应位都是1，则结果为1，否则为0	（A＆B），得到12，即0000 1100</p><p>|	如果相对应位都是 0，则结果为 0，否则为 1	（A | B）得到61，即 0011 1101</p><p>^	如果相对应位值相同，则结果为0，否则为1	（A ^ B）得到49，即 0011 0001</p><p>〜	按位取反运算符翻转操作数的每一位，即0变成1，1变成0。	（〜A）得到-61，即1100 0011</p><p>&lt;&lt; 	按位左移运算符。左操作数按位左移右操作数指定的位数。	A &lt;&lt; 2得到240，即 1111 0000</p><p>&gt;&gt; 	按位右移运算符。左操作数按位右移右操作数指定的位数。	A &gt;&gt; 2得到15即 1111</p><p>&gt;&gt;&gt; 	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。	A&gt;&gt;&gt;2得到15即0000 1111</p><p><b>逻辑运算符</b>#java/基础/运算符/逻辑运算符</p><p>&amp;&amp;	称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。	（A &amp;&amp; B）为假。</p><p>| |	称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。	（A | | B）为真。</p><p>！	称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。	！（A &amp;&amp; B）为真。</p><p><b>短路逻辑运算符</b>#java/基础/运算符/短路逻辑运算符</p><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p><p><b>赋值运算符</b>#java/基础/运算符/赋值运算符</p><p>=	简单的赋值运算符，将右操作数的值赋给左侧操作数	C = A + B将把A + B得到的值赋给C</p><p>+ =	加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数	C + = A等价于C = C + A</p><p>- =	减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数	C - = A等价于C = C - A</p><p>* =	乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数	C * = A等价于C = C * A</p><p>/ =	除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数	C / = A，C 与 A 同类型时等价于 C = C / A</p><p>（％）=	取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数	C％= A等价于C = C％A</p><p>&lt;&lt; =	左移位赋值运算符	C &lt;&lt; = 2等价于C = C &lt;&lt; 2</p><p>&gt;&gt; =	右移位赋值运算符	C &gt;&gt; = 2等价于C = C &gt;&gt; 2</p><p>＆=	按位与赋值运算符	C＆= 2等价于C = C＆2</p><p>^ =	按位异或赋值操作符	C ^ = 2等价于C = C ^ 2</p><p>| =	按位或赋值操作符	C | = 2等价于C = C | 2</p><p><b>条件运算符</b>#java/基础/运算符/条件运算符</p><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><p>instanceof 运算符#java/基础/运算符/instanceof 运算符</p><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p></p><p>instanceof运算符使用格式如下：</p><p></p><p>( Object reference variable ) instanceof (class/interface type)</p><p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p><p></p><p>下面是一个例子：</p><p></p><p>String name = "James";</p><p>boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真</p><p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p><p>Java运算符优先级#java/基础/运算符/Java运算符优先级</p><p>后缀	() [] . (点操作符)	左到右</p><p>一元	expr++ expr--	从左到右</p><p>一元	++expr --expr + - ～ ！	从右到左</p><p>乘性 	* /％	左到右</p><p>加性 	+ -	左到右</p><p>移位 	&gt;&gt; &gt;&gt;&gt;  &lt;&lt; 	左到右</p><p>关系 	&gt; &gt;= &lt; &lt;= 	左到右</p><p>相等 	==  !=	左到右</p><p>按位与	＆	左到右</p><p>按位异或	^	左到右</p><p>按位或	|	左到右</p><p>逻辑与	&amp;&amp;	左到右</p><p>逻辑或	| |	左到右</p><p>条件	？：	从右到左</p><p>赋值	= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =	从右到左</p><p>逗号	，	左到右</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 13:07:08</div>
                <div class="content">
                    <p>#java/基础/变量类型</p><p></p><p>菜鸟链接</p><p>https://www.runoob.com/java/java-variable-types.html</p><p>Java语言支持的变量类型有：</p><p></p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。</li></ul><p><b>局部变量#java/基础/变量类型/局部变量</b></p><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><p><b>实例变量</b>:#java/基础/变量类型/实例变量</p><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。</li></ul><p><b>类变量（静态变量）#java/基础/变量类型/类变量</b></p><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li><li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName的方式访问。</li><li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 12:44:06</div>
                <div class="content">
                    <p>#java/基础/基本数据类型</p><p></p><p><b>内置数据类型</b></p><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p><b>byte(字节型):#java/基础/基本数据类型/byte</b></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 -128（-2^7）；</li><li>最大值是 127（2^7-1）；</li><li>默认值是 0；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p><b>short(短整型):#java/基础/基本数据类型/short</b></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 0；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p><b>int (整型):#java/基础/基本数据类型/int</b></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 0 ；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p>long(长整型)#java/基础/基本数据类型/long</p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 0L；</li><li>例子： long a = 100000L，long b = -200000L。</li><li>"L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。</li></ul><p>float(单精度浮点):#java/基础/基本数据类型/float</p><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是 0.0f；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p>double(双精度浮点):#java/基础/基本数据类型/double</p><ul><li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</li><li>浮点数的默认类型为 double 类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 0.0d；</li></ul><p>例子：</p><ol><li>double d1 = 7D ;</li><li>double d2 = 7.;</li><li>double d3 = 8.0;</li><li>double d4 = 8.D;</li><li>double d5 = 12.9867;</li></ol><ul><li>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</li></ul><p>boolean(布尔型):#java/基础/基本数据类型/boolean</p><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 false；</li><li>例子：boolean one = true。</li></ul><p>char(字符型):#java/基础/基本数据类型/char</p><ul><li>char 类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 \u0000（十进制等效值为 0）；</li><li>最大值是 \uffff（即为 65535）；</li><li>char 数据类型可以储存任何字符；</li><li>例子：char letter = 'A';。</li></ul><p></p><p>public class PrimitiveTypeTest {  </p><p>    public static void main(String[] args) {  </p><p>        // byte  </p><p>        System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE);  </p><p>        System.out.println("包装类：java.lang.Byte");  </p><p>        System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE);  </p><p>        System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE);  </p><p>        System.out.println();  </p><p>  </p><p>        // short  </p><p>        System.out.println("基本类型：short 二进制位数：" + Short.SIZE);  </p><p>        System.out.println("包装类：java.lang.Short");  </p><p>        System.out.println("最小值：Short.MIN_VALUE=" + Short.MIN_VALUE);  </p><p>        System.out.println("最大值：Short.MAX_VALUE=" + Short.MAX_VALUE);  </p><p>        System.out.println();  </p><p>  </p><p>        // int  </p><p>        System.out.println("基本类型：int 二进制位数：" + Integer.SIZE);  </p><p>        System.out.println("包装类：java.lang.Integer");  </p><p>        System.out.println("最小值：Integer.MIN_VALUE=" + Integer.MIN_VALUE);  </p><p>        System.out.println("最大值：Integer.MAX_VALUE=" + Integer.MAX_VALUE);  </p><p>        System.out.println();  </p><p>  </p><p>        // long  </p><p>        System.out.println("基本类型：long 二进制位数：" + Long.SIZE);  </p><p>        System.out.println("包装类：java.lang.Long");  </p><p>        System.out.println("最小值：Long.MIN_VALUE=" + Long.MIN_VALUE);  </p><p>        System.out.println("最大值：Long.MAX_VALUE=" + Long.MAX_VALUE);  </p><p>        System.out.println();  </p><p>  </p><p>        // float  </p><p>        System.out.println("基本类型：float 二进制位数：" + Float.SIZE);  </p><p>        System.out.println("包装类：java.lang.Float");  </p><p>        System.out.println("最小值：Float.MIN_VALUE=" + Float.MIN_VALUE);  </p><p>        System.out.println("最大值：Float.MAX_VALUE=" + Float.MAX_VALUE);  </p><p>        System.out.println();  </p><p>  </p><p>        // double  </p><p>        System.out.println("基本类型：double 二进制位数：" + Double.SIZE);  </p><p>        System.out.println("包装类：java.lang.Double");  </p><p>        System.out.println("最小值：Double.MIN_VALUE=" + Double.MIN_VALUE);  </p><p>        System.out.println("最大值：Double.MAX_VALUE=" + Double.MAX_VALUE);  </p><p>        System.out.println();  </p><p>  </p><p>        // char  </p><p>        System.out.println("基本类型：char 二进制位数：" + Character.SIZE);  </p><p>        System.out.println("包装类：java.lang.Character");  </p><p>        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台  </p><p>        System.out.println("最小值：Character.MIN_VALUE="  </p><p>                + (int) Character.MIN_VALUE);  </p><p>        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台  </p><p>        System.out.println("最大值：Character.MAX_VALUE="  </p><p>                + (int) Character.MAX_VALUE);  </p><p>    }  </p><p>}</p><p>运行结果</p><p>基本类型：byte 二进制位数：8</p><p>包装类：java.lang.Byte</p><p>最小值：Byte.MIN_VALUE=-128</p><p>最大值：Byte.MAX_VALUE=127</p><p></p><p>基本类型：short 二进制位数：16</p><p>包装类：java.lang.Short</p><p>最小值：Short.MIN_VALUE=-32768</p><p>最大值：Short.MAX_VALUE=32767</p><p></p><p>基本类型：int 二进制位数：32</p><p>包装类：java.lang.Integer</p><p>最小值：Integer.MIN_VALUE=-2147483648</p><p>最大值：Integer.MAX_VALUE=2147483647</p><p></p><p>基本类型：long 二进制位数：64</p><p>包装类：java.lang.Long</p><p>最小值：Long.MIN_VALUE=-9223372036854775808</p><p>最大值：Long.MAX_VALUE=9223372036854775807</p><p></p><p>基本类型：float 二进制位数：32</p><p>包装类：java.lang.Float</p><p>最小值：Float.MIN_VALUE=1.4E-45</p><p>最大值：Float.MAX_VALUE=3.4028235E38</p><p></p><p>基本类型：double 二进制位数：64</p><p>包装类：java.lang.Double</p><p>最小值：Double.MIN_VALUE=4.9E-324</p><p>最大值：Double.MAX_VALUE=1.7976931348623157E308</p><p></p><p>基本类型：char 二进制位数：16</p><p>包装类：java.lang.Character</p><p>最小值：Character.MIN_VALUE=0</p><p>最大值：Character.MAX_VALUE=65535</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 11:11:21</div>
                <div class="content">
                    <p>#java/基础/对象，类</p><p></p><p><b>对象</b>:对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p><p><b>类</b>:类是一个模板，它描述一类对象的行为和状态。</p><p>一个类可以包含以下几个变量</p><ul><li><b>局部变量</b>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><b>成员变量</b>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><b>类变量</b>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><p><b>构造方法</b></p><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><p>如:</p><p>public class Main</p><p>{</p><p>	public Main(String nam){</p><p>		System.out.println(nam);</p><p>	}</p><p>	public static void main(String[] args)</p><p>	{</p><p>		//System.out.println("jsjs-");</p><p>		// 下面的语句将创建一个Main对象</p><p>		Main df=new Main("d");</p><p>	}</p><p>}</p><p></p><p><b>访问实例变量和方法</b></p><p> /* 实例化对象 */</p><p>Object referenceVariable = new Constructor();</p><p>/* 访问类中的变量 */</p><p>referenceVariable.variableName;</p><p>/* 访问类中的方法 */</p><p>referenceVariable.methodName();</p><p> 实例</p><p>下面的例子展示如何访问实例变量和调用成员方法：</p><p> public class Puppy{</p><p>   int puppyAge;</p><p>   public Puppy(String name){</p><p>      // 这个构造器仅有一个参数：name</p><p>      System.out.println("小狗的名字是 : " + name ); </p><p>   }</p><p> </p><p>   public void setAge( int age ){</p><p>       puppyAge = age;</p><p>   }</p><p> </p><p>   public int getAge( ){</p><p>       System.out.println("小狗的年龄为 : " + puppyAge ); </p><p>       return puppyAge;</p><p>   }</p><p> </p><p>   public static void main(String[] args){</p><p>      /* 创建对象 */</p><p>      Puppy myPuppy = new Puppy( "tommy" );</p><p>      /* 通过方法来设定age */</p><p>      myPuppy.setAge( 2 );</p><p>      /* 调用另一个方法获取age */</p><p>      myPuppy.getAge( );</p><p>      /*你也可以像下面这样访问成员变量  就是调用变量*/</p><p>      System.out.println("变量值 : " + myPuppy.puppyAge ); </p><p>   }</p><p>}</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 11:08:56</div>
                <div class="content">
                    <p>#java/基础/注释</p><p></p><p>//这是java单行注释</p><p>/*</p><p> 这是java多行注释</p><p>*/</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 10:33:09</div>
                <div class="content">
                    <p>#java/基础/关键字</p><p>&lt;注意：Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。&gt;</p><p>访问控制  </p><p><b>private</b>  私有的</p><p><b>protected</b>  受保护的</p><p><b>public</b>  公共的</p><p><b>default</b> 默认</p><p>**********************************************类，方法和变量修饰符</p><p><b>abstract</b>  声明抽象</p><p><b>class </b>类</p><p><b>extends</b> 扩充，继承</p><p><b>final</b> 最终值，不可改变的</p><p><b>implements</b> 实现(接口)</p><p><b>native</b> 本地，原生方法(非java实现)</p><p><b>new</b> 新，创建</p><p><b>static</b> 静态</p><p><b>strictfp</b> 严格，精准</p><p><b>synchronized</b> 线程，同步</p><p><b>transient</b> 短暂</p><p><b>volatile</b> 易失</p><p>**********************************************</p><p>程序控制语句</p><p><b>break</b> 跳出循环</p><p><b>case</b> 定义一个值供switch选择</p><p><b>continue</b> 继续</p><p><b>do</b> 运行</p><p><b>else</b> 否则</p><p><b>for</b> 循环</p><p><b>if</b> 如果</p><p><b>instanceof</b> 实例</p><p><b>return</b> 返回</p><p><b>switch</b> 根据值选择执行</p><p><b>while</b>循环</p><p>**********************************************</p><p>错误处理</p><p><b>asset</b> 判断表达式是否为真</p><p><b>catch</b> 捕捉异常</p><p><b>finally</b> 有没有异常都执行</p><p><b>throw</b> 抛出一个异常对象</p><p><b>throws</b> 声明一个异常可能被抛出</p><p><b>try</b> 捕获异常</p><p>**********************************************</p><p>包相关</p><p><b>import</b> 引入</p><p><b>package</b> 包</p><p>**********************************************</p><p>基本类型</p><p><b>boolean</b> 布尔型</p><p><b>byte</b> 字节型</p><p><b>char</b> 字符型</p><p><b>double</b> 双精度浮点</p><p><b>float</b> 单精度浮点</p><p><b>int</b> 整型</p><p><b>long</b> 长整型</p><p><b>short</b> 短整型</p><p>**********************************************</p><p>变量引用</p><p><b>super</b> 父类，超类</p><p><b>this</b> 本类</p><p><b>void</b> 无返回值</p><p>**********************************************</p><p>保留关键字</p><p>goto 是关键字，但不能使用</p><p>const 是关键字，但不能使用</p><p>**********************************************</p><p></p><p></p><p></p><p>                     </p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 10:31:45</div>
                <div class="content">
                    <p>#java</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                        <div class="memo">
                <div class="time">2022-10-16 10:29:00</div>
                <div class="content">
                    <p><strong>👋，吾友</strong></p>
            <p></p>
            <p>flomo 是新一代的极简备忘录，帮你降低记录成本，积累知识的复利。</p>
            <p></p>
            <p>除了在这个页面<strong>像发微博一样</strong>快速输入</p>
            <p><strong>你还可以通过「flomo」服务号输入</strong>（微信搜索 flomoapp 关注）</p>
            <p></p>
            <p>快去试试吧~ 如有问题，也欢迎加入共建微信群，戳↓</p><p>https://help.flomoapp.com/community/wechat-group.html</p>
                </div>
                <div class="files">
                                    </div>
            </div>
                    </div>
    </body>
</html>